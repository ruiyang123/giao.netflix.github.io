<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Netlfix Data Visulization</title>
    <meta
      name="description"
      content="Ce site permet de visualiser un jeu de données qui se compose des films et séries qui sont disponible sur la plateforme Netflix depuis 2008. Les données sont collectées depuis Flixable qui est un moteur de recherche pour Netflix."
    />
    <meta
      name="author"
      content="RUI Yang - EL MORABET Hicham - ELMAGHRAOUI Imran"
    />
    <meta property="og:title" content="Netlfix Data Visulization" />
    <meta
      property="og:description"
      content="Ce site permet de visualiser un jeu de données qui se compose des films et séries qui sont disponible sur la plateforme Netflix depuis 2008. Les données sont collectées depuis Flixable qui est un moteur de recherche pour Netflix."
    />
    <meta
      property="og:image"
      content="https://cdn.vox-cdn.com/thumbor/Yq1Vd39jCBGpTUKHUhEx5FfxvmM=/39x0:3111x2048/1200x800/filters:focal(39x0:3111x2048)/cdn.vox-cdn.com/uploads/chorus_image/image/49901753/netflixlogo.0.0.png"
    />

    <link
      rel="shortcut icon"
      type="image/png"
      href="https://cdn.vox-cdn.com/thumbor/Yq1Vd39jCBGpTUKHUhEx5FfxvmM=/39x0:3111x2048/1200x800/filters:focal(39x0:3111x2048)/cdn.vox-cdn.com/uploads/chorus_image/image/49901753/netflixlogo.0.0.png"
    />

    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
      integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" type="text/css" href="style.css" />

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <script src="https://d3js.org/d3-array.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.5.0/d3.js"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3-scale-radial.js"></script>
  </head>

  <body>
    <div class="page-holder bg-cover">
      <nav
        class="navbar navbar-expand-lg navbar-light bg-light bg-gradinent sticky-top"
      >
        <a class="navbar-brand text-white title-margin logo" href="#"
          >Netlfix Data Visulization</a
        >
      </nav>
      <div>
        <!-- ........ -->

        <!-- ........... -->
        <div class="container-fluid ">
          <div class="row">
            <main class="main-content col-lg-12 col-md-12 col-sm-12 ">
              <div class="h-100">
                <div
                  class="top-card col-xs-9 col-md-9 col-ms-9 col-lg-9 border m-2 ml-5"
                >
                  <div class="row">
                    <main class="main-content col-lg-12 col-md-12 col-sm-12 ">
                      <div class="h-100">
                        <div
                          id="map"
                          class="my-chart col-xs-11 col-md-11 col-ms-11 col-lg-11 border card m-2 ml-5"
                        >
                          <span id="t1"></span>
                          <!-- Map Container -->
                        </div>
                      </div>
                    </main>
                  </div>
                  <div class="row">
                    <main class="main-content col-lg-12 col-md-12 col-sm-12 ">
                      <div class="h-100">
                        <div
                          class="my-chart col-xs-11 col-md-11 col-ms-11 col-lg-11 border card m-2 ml-5"
                          id="bars"
                        >
                          <span id="t2"></span>
                        </div>
                      </div>
                    </main>
                  </div>
                  <div class="row">
                    <main class="main-content col-lg-12 col-md-12 col-sm-12 ">
                      <div class="h-100">
                        <div
                          class="my-chart col-xs-11 col-md-11 col-ms-11 col-lg-11 border card m-2 ml-5"
                          id="line"
                        >
                          <span id="t3"></span>
                        </div>
                      </div>
                    </main>
                  </div>
                  <div class="row">
                    <main class="main-content col-lg-12 col-md-12 col-sm-12  ">
                      <div class="h-100">
                        <div
                          class="my-chart col-xs-11 col-md-11 col-ms-11 col-lg-11 border card m-2 ml-5"
                          id="bars2"
                        >
                          <span id="t4"></span>
                        </div>
                      </div>
                    </main>
                  </div>
                  <div class="row">
                    <main class="main-content col-lg-12 col-md-12 col-sm-12 ">
                      <div class="h-100">
                        <div
                          class="my-chart col-xs-11 col-md-11 col-ms-11 col-lg-11 border card m-2 ml-5"
                          id="pie"
                        >
                          <span id="t5"></span>
                        </div>
                      </div>
                    </main>
                  </div>
                </div>
                <div
                  class="my-chart col-xs-2 col-md-2 col-ms-2 col-lg-2 border card m-2 mt-2"
                  id="my-parent"
                >
                  <div id="my-child">
                    <p class="text-justify p1">
                      <br />In this figure, we can observe four parts : the
                      geographical map which is colored by the number of TV show
                      and Movies, a legend which shows the color intensity,the
                      left text shows the interval and finally you can find a
                      text in the top which represent the type of the filter. At
                      first, we use no filter. So the number here is the total
                      number of TV shows and movies. If we use a filter for
                      example "TV-14", we will only consider the movies and TV
                      shows satisfies the filter "TV-14". The legend and text
                      will adapt with the filter.
                    </p>
                    <p class="text-justify p2">
                      <br />This graph shows the distribution of the number TV
                      shows and Movies in diffrent PG(parental guideline)
                      grouped by the Year.
                    </p>
                    <p class="text-justify p3">
                      <br />This graph shows the number of movies and TV shows
                      added to Netflix each year since 2008, as you can see the
                      graph is made up of two curves, one for Movies and the
                      other for TV shows,
                    </p>
                    <p class="text-justify p4">
                      <br />This graph shows the number of Movies according to
                      their periods in minutes.
                    </p>
                    <p class="text-justify p5">
                      <br />This graph shows the proportion of different
                      types(children, horrible,international movies) of movies.
                    </p>
                  </div>
                </div>
              </div>
            </main>
          </div>
        </div>
      </div>
    </div>
    <!-- Footer -->
    <footer class="page-footer font-small blue pt-4">
      <!-- Footer Links -->
      <div class="container-fluid text-center text-md-left">
        <!-- Grid row -->
        <div class="row">
          <!-- Grid column -->
          <div class="col-md-6 mt-md-0 mt-3">
            <!-- Content -->
            <h5 class="text-uppercase">Description :</h5>
            <p>
              The aim of this project is to make some visualisations based on a
              dataset which consists of films and TV shows which have been
              available on Netflix since 2008. We found the dataset from Kaggle.
              It is collected by a search engine named FLixable. In this
              project, we can observe the distribution of TV shows and movies in
              different country. There are 5 figures in total including a
              geomap, a stacked bar chart, a pie char, a bar char and a line
              char.
            </p>
          </div>
          <!-- Grid column -->

          <hr class="clearfix w-100 d-md-none pb-3" />

          <!-- Grid column -->
          <div class="col-md-3 mb-md-0 mb-3">
            <!-- Links -->
            <h5 class="text-uppercase">Authors :</h5>

            <ul class="list-unstyled">
              <li>
                <b>Rui Yang</b>
              </li>
              <li>
                <b>EL MORABET Hicham</b>
              </li>
              <li>
                <b>ELMAGHRAOUI Imran</b>
              </li>
            </ul>
          </div>
          <!-- Grid column -->

          <!-- Grid column -->
          <div class="col-md-3 mb-md-0 mb-3">
            <!-- Links -->
            <h5 class="text-uppercase">Useful Links :</h5>

            <ul class="list-unstyled">
              <li>
                <a href="https://www.kaggle.com/shivamb/netflix-shows"
                  >DataSet used
                </a>
              </li>
              <li>
                <a href="https://github.com/ruiyang123/giao.netflix.github.io"
                  >Github Repo</a
                >
              </li>
              <li>
                <a href="https://github.com/LyonDataViz/MOS5.5-Dataviz"
                  >Data Visulisation Course</a
                >
              </li>
            </ul>
          </div>
          <!-- Grid column -->
        </div>
        <!-- Grid row -->
      </div>
      <!-- Footer Links -->

      <!-- Copyright -->
      <div class="footer-copyright text-center py-3">
        © 2020 Copyright: Netflix Data Visulization
      </div>
      <!-- Copyright -->
    </footer>
    <!-- Footer -->

    <script>
      /*MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP
            ----------------------------------------------------------------
                  */

      var margin = { top: 20, right: 10, bottom: 20, left: 10 };
      var width = document.getElementById("map").clientWidth;
      console.log(width);
      //this allows us to collect the width of the div where the SVG will go.
      var height = width / 1.6;

      var xScale = d3
        .scaleLinear()
        .domain([-width / 2, width / 2])
        .range([0, width]);

      let div = d3
        .select("body")
        .append("div")
        .attr("class", "tooltip")
        .attr("id", "tooltip_map")
        .style("opacity", 0)
        .style("background-color", "#e5e5df");

      let div_stack_bar = d3
        .select("body")
        .append("div")
        .attr("class", "tooltip")
        .attr("id", "tooltip_stack_bar")
        .style("opacity", 0)
        .style("background-color", "#e5e5df");

      let compute2 = d3.interpolate("red", "blue");

      let scale = d3
        .scaleLog()
        .domain([1, 2000])
        .range([0, 1]);
      let scale2 = d3
        .scaleLinear()
        .domain([1, 1000])
        .range([0, 1]);
      //console.log(scale(4.5))
      //console.log(scale(Math.pow(max_v,0.3)))
      let colors = d3.scaleSequential(d3.interpolateReds);

      var view = null,
        currentTransform = null;
      var yScale = d3
        .scaleLinear()
        .domain([-height / 2, height / 2])
        .range([height, 0]);
      var color = d3.scaleOrdinal(d3.schemeCategory20);
      var svg = d3
        .select("#map")
        .append("svg")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("transform", "translate(" + -30 + "," + -30 + ")")
        .call(responsivefy);
      view = svg.append("g").attr("class", "view");
      if (currentTransform) view.attr("transform", currentTransform);

      var projection = d3
        .geoEqualEarth()
        .scale((width + 1) / 2 / Math.PI)
        .translate([width / 2, height / 2])
        .precision(0.1); //rotate([-10, 0]);

      var path = d3
        .geoPath() // d3.geo.path avec d3 version 3
        .projection(projection);
      d3.json(
        "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_geoMap/data_country.json",
        function(data) {
          d3.json(
            "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_stackedBar/data_diff_country.json",
            function(data2) {
              d3.json(
                "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_pieChart/new_data_type_country.json",
                function(data3) {
                  d3.json(
                    "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_geoMap/countries-50m.json",
                    function(error, world) {
                      // console.log(world.objects.countries.geometries)

                      //console.log(world.objects.countries.geometries);

                      for (var i in world.objects.countries.geometries) {
                        //console.log(world.objects.countries.geometries[i].properties);

                        world.objects.countries.geometries[i].properties[
                          "nomb"
                        ] = -1;
                        // console.log(world.objects.countries.geometries[i].properties)
                      }

                      for (var i = 0; i < data.length; i++) {
                        var country = data[i].country;
                        var tol_nom = data[i].value;

                        for (var j in world.objects.countries.geometries) {
                          if (
                            world.objects.countries.geometries[j].properties
                              .name == country
                          ) {
                            world.objects.countries.geometries[j].properties[
                              "nomb"
                            ] = tol_nom;
                          }
                        }
                      }

                      for (var i in world.objects.countries.geometries) {
                        //console.log(world.objects.countries.geometries[i].properties);

                        world.objects.countries.geometries[i].properties[
                          "genre_value"
                        ] = { country: "None", value_type: 0 };
                        world.objects.countries.geometries[i].properties[
                          "type_value"
                        ] = { country: "None", value: 0 };
                        // console.log(world.objects.countries.geometries[i].properties)
                      }

                      for (var i = 0; i < data2.length; i++) {
                        var country = data2[i].country;
                        var vt = data2[i].value_type;

                        for (var j in world.objects.countries.geometries) {
                          if (
                            world.objects.countries.geometries[j].properties
                              .name == country
                          ) {
                            world.objects.countries.geometries[j].properties[
                              "genre_value"
                            ] = vt;
                          }
                        }
                      }
                      for (var i = 0; i < data3.length; i++) {
                        // console.log(data3)
                        var country = data3[i].country;
                        var gt = data3[i].value;

                        for (var j in world.objects.countries.geometries) {
                          if (
                            world.objects.countries.geometries[j].properties
                              .name == country
                          ) {
                            world.objects.countries.geometries[j].properties[
                              "type_value"
                            ] = gt;
                          }
                        }
                      }
                      // console.log(world.objects.countries.geometries)

                      svg
                        .selectAll("path")
                        .data(
                          topojson.feature(world, world.objects.countries)
                            .features
                        )
                        .enter()
                        .append("path")
                        .attr("d", path)
                        .attr("id", "countryplot")
                        .style("stroke", "white")
                        .style("stroke-width", 0.3)
                        .attr("fill", function(d, i) {
                          if (d.properties.nomb > 1) {
                            return colors(scale(d.properties.nomb));
                          } else if (d.properties.nomb == -1) {
                            return "#e6e6e6";
                          } else {
                            return d3.rgb(254, 229, 217);
                          }
                        })
                        .on("click", function(d) {
                          drawCountry(
                            d.properties.genre_value,
                            d.properties.name
                          );
                          //console.log(d.properties.type_value)
                          drawPieChart(
                            d.properties.type_value,
                            d.properties.name
                          );

                          d3.json(
                            "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_lineChart/data_date_country.json",
                            function(error, data_line) {
                              if (error) throw error;

                              // trigger render
                              drawLine(data_line, d.properties.name);
                            }
                          );

                          d3.json(
                            "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_barChart/data_duration_country.json",
                            function(error, data_bar) {
                              if (error) throw error;

                              // trigger render
                              drawBar(data_bar, d.properties.name);
                            }
                          );

                          if (d.properties.nomb == -1) {
                            d3.json(
                              "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_lineChart/data_date_all.json",
                              function(error, data) {
                                if (error) throw error;

                                // trigger render
                                drawLine(data, "dates");
                              }
                            );

                            d3.json(
                              "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_barChart/data_duration_all.json",
                              function(error, data) {
                                if (error) throw error;

                                // trigger render
                                drawBar(data, "durations");
                              }
                            );
                          }
                        })
                        .on("mouseover", function(d) {
                          div
                            .transition()
                            .duration(100)
                            .style("opacity", 1);
                          if (d.properties.nomb > 0) {
                            div
                              .html(
                                "<b>" +
                                  d.properties.name +
                                  "</br>" +
                                  "total number :" +
                                  d.properties.nomb +
                                  "</b>"
                              )
                              .style("left", d3.event.pageX - 50 + "px")
                              .style("top", d3.event.pageY - 50 + "px");
                          } else {
                            div
                              .html(
                                "<b>" +
                                  d.properties.name +
                                  " </br>" +
                                  "Missing Data" +
                                  "</b>"
                              )
                              .style("left", d3.event.pageX - 50 + "px")
                              .style("top", d3.event.pageY - 50 + "px");
                          }
                          d3.select(this).attr("class", "hover");
                        })
                        .on("mouseout", function(d) {
                          d3.select(this).attr("class", "");
                          div
                            .transition()
                            .duration(300)
                            .style("opacity", 0);
                        });

                      document.getElementById("t1").innerHTML =
                        " Color by the number of TV show ansd Movies";
                    }
                  );
                }
              );
            }
          );
        }
      );
      createLegend(2000, 10);
      // zoom and pan
      var zoom = d3
        .zoom()
        .scaleExtent([0.5, 5])
        .translateExtent([
          [-width * 2, -height * 2],
          [width * 2, height * 2]
        ])
        .on("zoom", zoomed);

      function zoomed() {
        currentTransform = d3.event.transform;
        //console.log(currentTransform)
        svg.selectAll(".carte").attr("transform", currentTransform);
        //svg.selectAll(".tooltip").attr("transform", currentTransform);
      }
      svg.call(zoom);

      function createLegend(max_v, num_celles) {
        d3.selectAll("#legend").remove();

        let legend = d3
          .select("#map")
          .select("svg")
          .append("g")
          .attr("id", "legend")
          .attr("width", 100)
          .attr("height", height)
          .attr("transform", "translate(70, 100)");

        let scale = d3
          .scaleLog()
          .domain([1, max_v])
          .range([0, 1]);
        //console.log(scale(4.5))
        //console.log(scale(Math.pow(max_v,0.3)))
        let color = d3.scaleSequential(d3.interpolateReds);

        let colors = d3
          .range(num_celles)
          .map(function(d) {
            return color(scale(Math.pow(max_v, d / num_celles)));
          })
          .reverse();

        console.log(colors);
        var legendSize = 30;
        var legendWidth = 20;

        legend
          .selectAll()
          .data(colors)
          .enter()
          .append("svg:rect")
          .attr("height", legendSize + "px")
          .attr("width", legendWidth + "px")
          .attr("x", 5)
          .attr("y", function(d, i) {
            return i * legendSize;
          })
          .style("fill", function(d, i) {
            return d;
          })
          .on("mouseover", function(d, i) {
            //console.log(i)
            var b_inf = Math.pow(max_v, (num_celles - i - 1) / num_celles);
            var b_sup = Math.pow(max_v, (num_celles - i) / num_celles);

            console.log(b_inf, b_sup);

            d3.selectAll("#countryplot").attr("opacity", function(e) {
              //console.log(e);

              if (e.properties.nomb > b_sup || e.properties.nomb < b_inf) {
                if (e.properties.nomb >= max_v && b_sup == max_v) {
                  return 1;
                } else {
                  return 0.1;
                }
              }
            });
          })
          .on("mouseout", function(d) {
            d3.selectAll("#countryplot").attr("opacity", 1);
          });

        legend
          .append("svg:rect")
          .attr("height", legendWidth + "px")
          .attr("width", legendWidth + "px")
          .attr("x", 5)
          .attr("y", 320)
          .style("fill", "#e6e6e6")
          .on("mouseover", function(d, i) {
            d3.selectAll("#countryplot").attr("opacity", function(e) {
              if (e.properties.nomb > 0) {
                return 0.1;
              }
            });
          })
          .on("mouseout", function() {
            d3.selectAll("#countryplot").attr("opacity", 1);
          });

        d3.range(num_celles).map(function(d, i) {
          var val;
          val = parseInt(Math.pow(max_v, (num_celles - d - 1) / num_celles));
          legend
            .append("text")
            .text(val)
            .attr("x", -15)
            .attr("y", (i + 1) * legendSize)
            .style("font-size", "10px")
            .attr("fill", "black")
            .attr("class", "legend_text");
        });

        legend
          .append("text")
          .text("No-Data")
          .attr("x", -30)
          .attr("y", 335)
          .style("font-size", "10px")
          .attr("fill", "black");
      }

      /*MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP
            ----------------------------------------------------------------
                  */

      function drawCountry(data, country_name) {
        test = data.country;

        d3.json(
          "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_stackedBar/data2.json",
          function(data2) {
            console.log(data);
            if (data.country == "None") {
              data = data2;
            }

            //  console.log(data)

            var margin = { top: 100, right: 10, bottom: 20, left: 10 };
            // width = 960 - margin.left - margin.right,
            // height = 500 - margin.top - margin.bottom;
            var width =
              document.getElementById("bars").clientWidth -
              margin.left -
              margin.right -
              100;
            console.log(width);
            //this allows us to collect the width of the div where the SVG will go.
            var height = width / 1.5 - margin.top - margin.bottom + 50;

            var y = d3
              .scaleLinear()
              .rangeRound([height, 0])
              .nice();

            var x = d3
              .scaleBand()
              .rangeRound([0, width])
              .paddingInner(0.05)
              .align(0.1);

            var z = d3.scaleOrdinal(d3.schemeCategory20);

            var parseTime = d3.timeParse("%Y");

            var symbols = [];

            for (var key in data[0]) {
              if (key != "year") {
                symbols.push(key);
              }
            }

            //console.log(symbols)

            var years = data.map(function(d) {
              return d.year;
            });

            var layers = d3.stack().keys(symbols)(data);

            var max = d3.max(layers[layers.length - 1], function(d) {
              return d[1];
            });

            y.domain([0, max]);
            x.domain(years);
            d3.selectAll("#countryPlot").remove();

            var svg = d3
              .select("#bars")
              .append("svg")
              // .attr("width", width + margin.left + margin.right)
              // .attr("height", height + margin.top + margin.bottom)
              .attr("width", "100%")
              .attr("height", "100%")

              .attr("id", "countryPlot")
              .append("g")
              .attr("transform", "translate(" + 40 + "," + 10 + ")")
              .call(responsivefy);
            //console.log(layers[2].key)
            svg
              .append("g")
              .selectAll("g")
              .data(layers)
              .enter()
              .append("g")
              .style("fill", function(d) {
                return z(d.key);
              })
              .attr("class", function(d) {
                return d.key;
              })
              .attr("id", "stack")
              .on("mouseover", function(d) {
                svg
                  .selectAll("#stack")
                  .filter(function(e) {
                    // console.log(e.key)
                    console.log(d.key);
                    return e.key !== d.key;
                  })
                  .style("opacity", 0.3);

                svg
                  .selectAll("#leg")
                  .filter(function(e) {
                    // console.log(e)
                    //console.log(z(d.key))
                    return e !== z(d.key);
                  })
                  .style("opacity", 0.3);
              })

              .on("click", function(d) {
                document.getElementById("t1").innerHTML =
                  "color by the cumulative number of " + d.key;

                var loc_max = 0;

                // console.log(d.data.name)
                d3.selectAll("#countryplot").attr("fill", function(e) {
                  var val2 = -1;
                  if (e.properties.genre_value.country !== "None") {
                    //console.log(e.properties.genre_value)
                    e.properties.genre_value.forEach(function(k) {
                      //console.log(k["NR"])
                      //console.log(typeof(k[d.key]))
                      if (typeof k[d.key] !== "undefined") {
                        k[d.key] = +k[d.key];
                        val2 = val2 + k[d.key];
                        if (loc_max < val2) {
                          loc_max = val2;
                        }
                      }
                    });
                    //console.log(val2);
                    if (val2 !== -1) {
                      e.properties.nomb = val2 + 1;
                      return d3.rgb(120, 120, 120);
                    } else {
                      e.properties.nomb = -1;
                      return d3.rgb(120, 120, 120);
                    }
                  } else {
                    return d3.rgb(120, 120, 120);
                  }
                });

                var new_scale = d3
                  .scaleLog()
                  .domain([1, loc_max])
                  .range([0, 1]);

                var new_colors = d3.scaleSequential(d3.interpolateReds);

                createLegend(loc_max, 10);

                d3.selectAll("#countryplot").attr("fill", function(e) {
                  var val2 = -1;
                  console.log(e);
                  if (e.properties.genre_value.country !== "None") {
                    //console.log(e.properties.genre_value)
                    e.properties.genre_value.forEach(function(k) {
                      //console.log(k["NR"])
                      //console.log(typeof(k[d.key]))
                      if (typeof k[d.key] !== "undefined") {
                        k[d.key] = +k[d.key];
                        val2 = val2 + k[d.key];
                        if (loc_max < val2) {
                          loc_max = val2;
                        }
                      }
                    });
                    //console.log(val2);
                    if (val2 !== -1) {
                      e.properties.nomb = val2 + 1;
                      return new_colors(new_scale(e.properties.nomb));
                    } else {
                      e.properties.nomb = -1;
                      return "#e6e6e6";
                    }
                  } else {
                    return "#e6e6e6";
                  }
                });
              })
              .on("mouseout", function(d) {
                svg.selectAll("#stack").style("opacity", 1);
                svg.selectAll("#leg").style("opacity", 1);
              })
              //.on("mouseover",function(d){ svg.selectAll("."+d.key).style("opacity",1)})

              .selectAll("rect")
              .data(function(d) {
                return d;
              })
              .enter()
              .append("rect")
              .attr("x", function(d, i) {
                return x(d.data.year);
              })
              .attr("y", function(d) {
                return y(d[1]);
              })
              .attr("height", function(d) {
                return y(d[0]) - y(d[1]);
              })
              .attr("width", x.bandwidth())
              .on("mouseover", function(d) {
                var type;
                var number = d[1] - d[0];

                for (var key in d.data) {
                  if (d.data[key] == number) {
                    type = key;
                  }
                }

                console.log(type);
                //console.log(1);
                div_stack_bar
                  .transition()
                  .duration(100)
                  .style("opacity", 1);

                div_stack_bar
                  .html(
                    "Type :" +
                      type +
                      "</br>" +
                      "year :" +
                      d.data.year +
                      "</br>" +
                      "number :" +
                      (d[1] - d[0])
                  )
                  .style("left", d3.event.pageX - 50 + "px")
                  .style("top", d3.event.pageY - 50 + "px");
              })
              .on("mouseout", function() {
                div_stack_bar
                  .transition()
                  .duration(300)
                  .style("opacity", 0);
              });

            var colors = symbols.map(function(d) {
              return z(d);
            });
            //console.log(colors)

            svg
              .append("g")
              .attr("class", "x axis")
              .attr("transform", "translate(0," + height + ")")
              .call(d3.axisBottom(x));

            svg
              .append("g")
              .attr("class", "y axis")
              .attr("transform", "translate(" + 0 + ", 0)")
              .call(d3.axisLeft().scale(y));
            // console.log(layers)

            var legend = svg
              .selectAll(".legend")
              .data(colors)
              .enter()
              .append("g")
              .attr("class", "legend")
              .attr("transform", function(d, i) {
                return "translate(30, " + i * 10 + ")";
              });

            legend
              .append("rect")
              .attr("id", "leg")
              .attr("x", 18)
              .attr("width", 9)
              .attr("height", 9)
              .style("fill", function(d, i) {
                return z(symbols[i]);
              });

            legend
              .append("text")
              .attr("x", 36)
              .attr("y", 9)
              .attr("dy", ".15em")
              .style("text-anchor", "start")
              .attr("font-size", 10)
              .text(function(d, i) {
                return symbols[i];
              });

            var tooltip = svg
              .append("g")
              .attr("class", "tooltip")
              .style("display", "none");

            tooltip
              .append("rect")
              .attr("width", 30)
              .attr("height", 20)
              .attr("fill", "white")
              .style("opacity", 0.5);

            tooltip
              .append("text")
              .attr("x", 15)
              .attr("dy", "1.2em")
              .style("text-anchor", "middle")
              .attr("font-size", "12px")
              .attr("font-weight", "bold");

            if (test == "None") {
              document.getElementById("t2").innerHTML =
                "Tout le monde : Rating and Quantity in different year";
            } else {
              document.getElementById("t2").innerHTML =
                country_name + " : Rating and Quantity in different year";
            }
          }
        );
      }

      var linear2 = d3
        .scaleLinear()
        .domain([0, 100])
        .range([0, 1]);

      function drawPieChart(data, country_name) {
        var test = data.country;
        d3.json(
          "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_pieChart/new_data_type.json",
          function(data2) {
            if (data.country == "None") {
              data = data2;
            }

            var margin = { top: 100, right: 0, bottom: 0, left: 0 };
            var width = document.getElementById("pie").clientWidth - 250;
            console.log(width);
            //this allows us to collect the width of the div where the SVG will go.
            var height = width / 2 - 100;
            var innerRadius = 40,
              outerRadius = 300;
            var svg = d3
              .select("#pie")
              .append("svg")
              .attr("width", "100%")
              .attr("height", "100%")
              .attr(
                "transform",
                "translate(" + width / 9 + "," + height / 9 + ")"
              )
              .attr("id", "countryPlot")
              .call(responsivefy);
            var el = svg
              .append("g")
              .attr(
                "transform",
                "translate(" +
                  (width / 2 + margin.left) +
                  "," +
                  (height / 2 + margin.top) +
                  ")"
              );

            // sort years ascending
            // data.sort(function(a, b) {
            //   return a["value"] - b["value"];
            // });
            var x = d3
              .scaleBand()
              .range([0, 2 * Math.PI]) // X axis goes from 0 to 2pi = all around the circle. If I stop at 1Pi, it will be around a half circle
              .align(0) // This does nothing
              .domain(
                data.map(function(d) {
                  return d.name;
                })
              ); // The domain of the X axis is the list of states.
            var y = d3
              .scaleRadial()
              .range([innerRadius, outerRadius]) // Domain will be define later.
              .domain([0, 14000]); // Domain of Y is from 0 to the max seen in the data

            var tooltip = d3
              .select("body")
              .append("div")
              .style("opacity", 0)
              .attr("class", "tooltip")
              .style("background-color", "white")
              .style("border", "solid")
              .style("border-width", "2px")
              .style("border-radius", "5px")
              .style("padding", "5px")
              .style("position", "absolute");

            // A function that change this tooltip when the user hover a point.
            // Its opacity is set to 1: we can now see it. Plus it set the text and position of tooltip depending on the datapoint (d)
            var showTooltip = function(d) {
              tooltip
                .transition()
                .duration(100)
                .style("opacity", 1);
              tooltip
                .html(
                  "Type : " +
                    d.name +
                    "<br/>Number of Movies & TV Shows : " +
                    d.value
                )
                .style("left", d3.event.pageX - 50 + "px")
                .style("top", d3.event.pageY - 50 + "px");
            };
            var moveTooltip = function(d) {
              tooltip
                .style("left", d3.event.pageX - 50 + "px")
                .style("top", d3.event.pageY - 50 + "px");
            };
            // A function that change this tooltip when the leaves a point: just need to set opacity to 0 again
            var hideTooltip = function(d) {
              tooltip
                .transition()
                .duration(100)
                .style("opacity", 0);
            };

            // Add the bars
            el.append("g")
              .selectAll("path")
              .data(data)
              .enter()
              .append("path")
              .attr("fill", "#69b3a2")
              .attr(
                "d",
                d3
                  .arc() // imagine your doing a part of a donut plot
                  .innerRadius(innerRadius)
                  .outerRadius(function(d) {
                    return y(d["value"]);
                  })
                  .startAngle(function(d) {
                    return x(d.name);
                  })
                  .endAngle(function(d) {
                    return x(d.name) + x.bandwidth();
                  })
                  .padAngle(0.01)
                  .padRadius(innerRadius)
              )
              .on("click", function(d) {
                document.getElementById("t1").innerHTML =
                  "color by the cumulative number of " + d.name;
                var loc_max = 0;
                // console.log(d.data.name)
                d3.selectAll("#countryplot").attr("fill", function(e) {
                  var val2 = -1;
                  //console.log(e);
                  if (e.properties.type_value.country !== "None") {
                    /// console.log(e.properties.type_value)

                    e.properties.type_value.forEach(function(k) {
                      // console.log(k)
                      if (k.name == d.name) {
                        k.value = +k.value;
                        val2 = val2 + k.value;
                        if (loc_max < val2) {
                          loc_max = val2;
                        }
                      }
                    });
                    //console.log(val2);
                    if (val2 !== -1) {
                      e.properties.nomb = val2 + 1;
                      return d3.rgb(120, 120, 120);
                    } else {
                      e.properties.nomb = -1;
                      return d3.rgb(120, 120, 120);
                    }
                  } else {
                    return d3.rgb(120, 120, 120);
                  }
                });

                console.log(loc_max);
                var new_scale = d3
                  .scaleLog()
                  .domain([1, loc_max])
                  .range([0, 1]);

                var new_colors = d3.scaleSequential(d3.interpolateReds);

                createLegend(loc_max, 10);

                d3.selectAll("#countryplot").attr("fill", function(e) {
                  var val2 = -1;

                  if (e.properties.type_value.country !== "None") {
                    //console.log(e.properties.genre_value)
                    e.properties.type_value.forEach(function(k) {
                      // console.log(k)
                      if (k.name == d.name) {
                        k.value = +k.value;
                        val2 = val2 + k.value;
                        if (loc_max < val2) {
                          loc_max = val2;
                        }
                      }
                    });
                    console.log(val2);
                    //console.log(val2);
                    if (val2 !== -1) {
                      e.properties.nomb = val2 + 1;
                      console.log(e.properties.nomb);
                      return new_colors(new_scale(e.properties.nomb));
                    } else {
                      e.properties.nomb = -1;
                      return "#e6e6e6";
                    }
                  } else {
                    return "#e6e6e6";
                  }
                });
              })
              .on("mouseover", showTooltip)
              .on("mousemove", moveTooltip)
              .on("mouseleave", hideTooltip);

            // Add the labels
            el.append("g")
              .selectAll("g")
              .data(data)
              .enter()
              .append("g")
              .attr("text-anchor", function(d) {
                return (x(d.name) + x.bandwidth() / 2 + Math.PI) %
                  (2 * Math.PI) <
                  Math.PI
                  ? "end"
                  : "start";
              })
              .attr("transform", function(d) {
                return (
                  "rotate(" +
                  (((x(d.name) + x.bandwidth() / 2) * 180) / Math.PI - 90) +
                  ")" +
                  "translate(" +
                  (y(d["value"]) + 10) +
                  ",0)"
                );
              })
              .append("text")
              .text(function(d) {
                return d.name;
              })
              .attr("transform", function(d) {
                return (x(d.name) + x.bandwidth() / 2 + Math.PI) %
                  (2 * Math.PI) <
                  Math.PI
                  ? "rotate(180)"
                  : "rotate(0)";
              })
              .style("font-size", "11px")
              .attr("alignment-baseline", "middle");

            if (test == "None") {
              document.getElementById("t5").innerHTML = " Tout le monde";
            } else {
              document.getElementById("t5").innerHTML = country_name;
            }
          }
        );
      }

      function drawLine(data, root) {
        d3.selectAll("#linePlot").remove();
        // set the dimensions and margins of the graph
        var margin = { top: 20, right: 10, bottom: 20, left: 10 };
        var width = document.getElementById("line").clientWidth - 140;

        var height = width - 340;

        var parseTime = d3.timeParse("%Y");
        var formatTime = d3.timeFormat("%Y");
        //this allows us to collect the width of the div where the SVG will go.

        var svg = d3
          .select("#line")
          .append("svg")
          .attr("id", "linePlot")
          .attr("width", "120%")
          .attr("height", "100%")
          .append("g")
          .attr("transform", "translate(" + 40 + "," + 22 + ")")
          .call(responsivefy);

        var data = data[root];

        // sort years ascending
        data.sort(function(a, b) {
          return a["date"] - b["date"];
        });

        data.forEach(function(d) {
          d.date = parseTime(d.date);
        });
        // List of groups (here I have one group per column)
        var allGroup = ["Movies", "TV_Show"];

        // Reformat the data: we need an array of arrays of {x, y} tuples
        var dataReady = allGroup.map(function(grpName) {
          // .map allows to do something for each element of the list
          return {
            name: grpName,
            values: data.map(function(d) {
              return { date: d.date, value: +d[grpName], type: grpName };
            })
          };
        });
        // I strongly advise to have a look to dataReady with
        // console.log(dataReady)

        // A color scale: one color for each group
        var myColor = d3
          .scaleOrdinal()
          .domain(allGroup)
          .range(d3.schemeSet2);

        // Add X axis --> it is a date format
        var x = d3
          .scaleTime()
          .domain(
            d3.extent(data, function(d) {
              return d.date;
            })
          )
          .range([0, width]);
        svg
          .append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

        // Add Y axis
        var y = d3
          .scaleLinear()
          .domain([
            d3.min(dataReady, function(c) {
              return d3.min(c.values, function(v) {
                return v.value;
              });
            }),
            d3.max(dataReady, function(c) {
              return d3.max(c.values, function(v) {
                return v.value;
              });
            })
          ])
          .range([height, 0]);
        svg
          .append("g")
          .call(d3.axisLeft(y))
          .append("text")
          .attr("class", "axis-title")
          .attr("transform", "rotate(-90)")
          .attr("y", 6)
          .attr("dy", ".71em")
          .style("text-anchor", "end")
          .attr("fill", "#5D6971")
          .attr("font-size", "1.2em")
          .attr("font-family", "Arial")
          .text("Number of Moviess / TV Show");

        // Add the lines
        var line = d3
          .line()
          .x(function(d) {
            return x(+d.date);
          })
          .y(function(d) {
            return y(+d.value);
          });

        svg
          .selectAll("myLines")
          .data(dataReady)
          .enter()
          .append("path")
          .attr("class", function(d) {
            return d.name;
          })
          .attr("d", function(d) {
            return line(d.values);
          })
          .attr("stroke", function(d) {
            return myColor(d.name);
          })
          .style("stroke-width", 4)
          .style("fill", "none");

        // create a tooltip
        var Tooltip = d3
          .select("body")
          .append("span")
          .style("opacity", 0)
          .attr("class", "tooltip")
          .style("background-color", "white")
          .style("border", "solid")
          .style("border-width", "2px")
          .style("border-radius", "5px")
          .style("padding", "5px")
          .style("position", "absolute");

        // Three function that change the tooltip when user hover / move / leave a cell
        var mouseover = function(d) {
          Tooltip.style("opacity", 1);
        };
        var mousemove = function(d) {
          Tooltip.html(
            "Year : " +
              formatTime(d.date) +
              "<br/>" +
              "Number of " +
              d.type +
              " : " +
              d.value
          )
            .style("left", d3.event.pageX - 50 + "px")
            .style("top", d3.event.pageY - 50 + "px");
        };
        var mouseleave = function(d) {
          Tooltip.style("opacity", 0);
        };

        // Add the points
        svg
          // First we need to enter in a group
          .selectAll("myDots")
          .data(dataReady)
          .enter()
          .append("g")
          .style("fill", function(d) {
            return myColor(d.name);
          })
          .attr("class", function(d) {
            return d.name;
          })
          // Second we need to enter in the 'values' part of this group
          .selectAll("myPoints")
          .data(function(d) {
            return d.values;
          })
          .enter()
          .append("circle")
          .attr("cx", function(d) {
            return x(d.date);
          })
          .attr("cy", function(d) {
            return y(d.value);
          })
          .attr("r", 5)
          .attr("stroke", "white")
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave);

        // Add a label at the end of each line
        svg
          .selectAll("myLabels")
          .data(dataReady)
          .enter()
          .append("g")
          .append("text")
          .attr("class", function(d) {
            return d.name;
          })
          .datum(function(d) {
            return { name: d.name, value: d.values[d.values.length - 1] };
          }) // keep only the last value of each time series
          .attr("transform", function(d) {
            return (
              "translate(" + x(d.value.date) + "," + y(d.value.value) + ")"
            );
          }) // Put the text at the position of the last point
          .attr("x", 12) // shift the text a bit more right
          .text(function(d) {
            if (d.name == "Movies") return "Movie";
            else return "TV Show";
          })
          .style("fill", function(d) {
            return myColor(d.name);
          })
          .style("font-size", 15);

        // Add a legend (interactive)
        svg
          .selectAll("myLegend")
          .data(dataReady)
          .enter()
          .append("g")
          .append("text")
          .attr("x", function(d, i) {
            return 30 + i * 60;
          })
          .attr("y", 30)
          .text(function(d) {
            if (d.name == "Movies") return "Movie";
            else return "TV Show";
          })
          .style("fill", function(d) {
            return myColor(d.name);
          })
          .style("font-size", 15)
          .on("click", function(d) {
            // is the element currently visible ?
            currentOpacity = d3.selectAll("." + d.name).style("opacity");
            // Change the opacity: from 0 to 1 or from 1 to 0
            d3.selectAll("." + d.name)
              .transition()
              .style("opacity", currentOpacity == 1 ? 0 : 1);
          });

        // Add title
        if (root == "dates") {
          // svg
          //   .append("text")
          //   .text("Tous : Movies and TV Shows per year")
          //   .attr("y", 20)
          //   .attr("x", 80)
          //   .attr("font-size", 14)
          //   .attr("font-family", "Consolas");

          document.getElementById("t3").innerHTML =
            "Tous : Movies and TV Shows per year";
        } else {
          // svg
          //   .append("text")
          //   .text(root + " : Movies and TV Shows per year")
          //   .attr("y", 20)
          //   .attr("x", 80)
          //   .attr("font-size", 14)
          //   .attr("font-family", "Consolas");
          document.getElementById("t3").innerHTML =
            root + " : Movies and TV Shows per year";
        }
      }

      function drawBar(data, root) {
        var margin = { top: 150, right: 10, bottom: 20, left: 10 };
        var width = document.getElementById("bars2").clientWidth - 100;
        console.log(width);
        //this allows us to collect the width of the div where the SVG will go.
        var height = width / 1.5 - margin.top - margin.bottom + 30;
        // set the ranges
        var x = d3
          .scaleBand()
          .range([0, width])
          .padding(0.1);
        var y = d3.scaleLinear().range([height, 0]);
        d3.selectAll("#bar_plot").remove();

        var svg = d3
          .select("#bars2")
          .append("svg")
          .attr("id", "bar_plot")
          .attr("width", "100%")
          .attr("height", "100%")
          .append("g")
          .attr("transform", "translate(" + 40 + "," + 50 + ")")
          .call(responsivefy);

        data = data[root];
        data.forEach(function(d) {
          d.duration = d.duration;
          d.value = +d.value;
        });

        data.sort(function(a, b) {
          return a["duration"] - b["duration"];
        });

        // Scale the range of the data in the domains
        x.domain(
          data.map(function(d) {
            return d.duration;
          })
        );
        y.domain([
          0,
          d3.max(data, function(d) {
            return d.value;
          })
        ]);

        var tooltip = d3
          .select("body")
          .append("div")
          .style("opacity", 0)
          .attr("class", "tooltip")
          .style("background-color", "white")
          .style("border", "solid")
          .style("border-width", "2px")
          .style("border-radius", "5px")
          .style("padding", "5px")
          .style("position", "absolute");

        var showTooltip = function(d) {
          tooltip
            .transition()
            .duration(100)
            .style("opacity", 1);
          tooltip
            .html("Range: " + d.duration + " - " + (d.duration + 10) + " min")
            .style("left", d3.event.pageX - 50 + "px")
            .style("top", d3.event.pageY - 50 + "px");
        };

        var moveTooltip = function(d) {
          tooltip
            .style("left", d3.event.pageX - 50 + "px")
            .style("top", d3.event.pageY - 50 + "px");
        };
        // A function that change this tooltip when the leaves a point: just need to set opacity to 0 again
        var hideTooltip = function(d) {
          tooltip
            .transition()
            .duration(100)
            .style("opacity", 0);
        };

        // append the rectangles for the bar chart
        svg
          .selectAll(".bar")
          .data(data)
          .enter()
          .append("rect")
          .attr("class", "bar")
          .attr("x", function(d) {
            return x(d.duration);
          })
          .attr("width", x.bandwidth())
          .attr("y", function(d) {
            return y(d.value);
          })
          .attr("height", function(d) {
            return height - y(d.value);
          })
          .attr("fill", "steelblue")
          .on("mouseover", showTooltip)
          .on("mousemove", moveTooltip)
          .on("mouseleave", hideTooltip);
        // add the x Axis
        svg
          .append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

        // add the y Axis
        svg
          .append("g")
          .call(d3.axisLeft(y))
          .append("text")
          .attr("class", "axis-title")
          .attr("transform", "rotate(-90)")
          .attr("y", 6)
          .attr("dy", ".71em")
          .style("text-anchor", "end")
          .attr("fill", "#5D6971")
          .attr("font-size", "1.2em")
          .attr("font-family", "Arial")
          .text("Number of Moviess / TV Show");

        // add the x Axis
        svg
          .append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

        // add the y Axis
        svg.append("g").call(d3.axisLeft(y));

        if (root == "durations") {
          document.getElementById("t4").innerHTML = "Tous : Durations";
        } else {
          document.getElementById("t4").innerHTML = root + " : Durations";
        }
      }

      var data = { country: "None" };
      drawCountry(data, "None");
      drawPieChart(data, "None");

      d3.json(
        "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_lineChart/data_date_all.json",
        function(error, data) {
          if (error) throw error;

          // trigger render
          drawLine(data, "dates");
        }
      );

      d3.json(
        "https://raw.githubusercontent.com/ruiyang123/giao.netflix.github.io/master/data/data_barChart/data_duration_all.json",
        function(error, data) {
          if (error) throw error;

          // trigger render
          drawBar(data, "durations");
        }
      );

      //RESPONSIVEFY
      function responsivefy(svg) {
        // get container + svg aspect ratio
        var container = d3.select(svg.node().parentNode),
          width = parseInt(svg.style("width")),
          height = parseInt(svg.style("height")),
          aspect = width / height;

        // add viewBox and preserveAspectRatio properties,
        // and call resize so that svg resizes on inital page load
        svg
          .attr("viewBox", "0 0 " + width + " " + height)
          .attr("perserveAspectRatio", "xMinYMid")
          .call(resize);

        // to register multiple listeners for same event type,
        // you need to add namespace, i.e., 'click.foo'
        // necessary if you call invoke this function for multiple svgs
        // api docs: https://github.com/mbostock/d3/wiki/Selections#on
        d3.select(window).on("resize." + container.attr("id"), resize);

        // get width of container and resize svg to fit it
        function resize() {
          var targetWidth = parseInt(container.style("width"));
          svg.attr("width", targetWidth);
          svg.attr("height", Math.round(targetWidth / aspect));
        }
      }
    </script>
  </body>
</html>
